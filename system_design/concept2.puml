@startuml

' Configuration for better readability
skinparam classAttributeIconSize 0

' --- Identity and Ownership (Data Custodianship) ---
class IdentityOwner {
  - userDID: address
  - creditTier: String
  - riskScore: Integer
  - incomeBand: String
  - netWorth: Decimal
  - dataPointer: bytes32 <<Off-chain hash>>
  - registeredAt: DateTime
  - active: Boolean
}

class Consent {
  - consentID: bytes32
  - ownerDID: address
  - requesterID: address
  - dataType: String
  - purpose: String
  - purposeTier: String
  - startDate: DateTime
  - endDate: DateTime
  - status: String
  - dataPointer: bytes32 <<Off-chain hash>>
  - rewardMinted: Boolean
  + createConsent(): void
  + revokeConsent(): void
  + isValid(): Boolean
}

class AccessLog {
  - logID: bytes32
  - ownerDID: address
  - requesterID: address
  - dataType: String
  - purpose: String
  - consentID: bytes32
  - timestamp: DateTime
  - success: Boolean
  - details: String
}

' --- System Components (On-Chain/Service Layer) ---

class Requester {
  - requesterID: address
  - requesterType: String
  - currentPurpose: String
  - requestedData: List<String>
  + declarePurpose(purpose: String): void
  + requestData(ownerDID: address, dataType: String, purpose: String): void
  + verifyConsent(ownerDID: address, purpose: String): Boolean
  + accessData(ownerDID: address, purpose: String): String
}

class IdentityRegistry  {
  - profiles: Map<address, IdentityOwner> 
  + registerUser(dataPointer: bytes32): void
  + updateSummary(userDID: address, creditTier: String, riskScore: Integer, incomeBand: String, netWorth: Decimal): void
  + updateDataPointer(userDID: address, dataPointer: bytes32): void
  + getUserSummary(userDID: address): IdentityOwner
  + isRegistered(userDID: address): Boolean
}

class ConsentManager  {
  - consents: Map<bytes32, Consent> 
  - ownerConsents: Map<address, List<bytes32>> 
  + setConsent(ownerDID: address, requesterID: address, dataType: String, purpose: String, purposeTier: String, durationDays: Integer, dataPointer: bytes32): bytes32
  + revokeConsent(consentID: bytes32): void
  + isConsentValid(ownerDID: address, requesterID: address, dataType: String, purpose: String): Boolean
  + getConsent(consentID: bytes32): Consent
}

class DataSharing  {
  - accessLogs: Map<bytes32, AccessLog> 
  + shareData(ownerDID: address, dataPointer: bytes32): void
  + requestAccess(ownerDID: address, requesterID: address, dataType: String, purpose: String): bytes32 
  + createAccessLog(ownerDID: address, requesterID: address, dataType: String, purpose: String, consentID: bytes32, success: Boolean): void
  + getAccessLogs(ownerDID: address): List<AccessLog>
}

class TokenRewards {
  - tokenName: String
  - tokenSymbol: String
  - rewardRate: Map<String, Decimal>
  - researchWhitelist: List<String>
  - rewardedConsents: Map<bytes32, Boolean>
  + mintForConsent(ownerDID: address, consentID: bytes32, purposeTier: String): void
  + isEligibleResearch(requesterID: address, purpose: String): Boolean
  + setRewardRate(purpose: String, newRate: Decimal): void
}

class PurposeRegistry {
  - allowedPurposes: List<String>
  - purposeTiers: Map<String, String>
  + isAllowed(purpose: String): Boolean
  + getTier(purpose: String): String
}

class FinancialDataService  {
  - documents: Map<address, String> 
  - calculatedScores: Map<address, Decimal> 
  + calculateCreditScore(ownerDID: address): Decimal
  + requestOwnerData(ownerDID: address, dataType: String): String
  + generateSummary(ownerDID: address): String
}

' --- Relationships ---

' Identity Owner owns the data
IdentityOwner "1" -- "0..*" Consent : grants >
IdentityOwner "1" -- "0..*" AccessLog : generates >

' Registry manages the Identity Owner's existence (DID)
IdentityRegistry "1" -- "0..*" IdentityOwner : registers >

' Management of Consent
Requester "1" -- "0..*" Consent : requests >
ConsentManager "1" -- "0..*" Consent : manages >

' Data Flow and Access Control
Requester "1" -> "1" DataSharing : requests data from >

DataSharing "1" --> "1" ConsentManager : verifies consent via >
DataSharing "1" --> "1" IdentityRegistry : fetches pointers from >
DataSharing "1" --> "1" AccessLog : writes audit to >
DataSharing "1" ..> "1" FinancialDataService : provides authorized data to
DataSharing "1" --> "1" PurposeRegistry : validates purpose >

TokenRewards "1" --> "0..*" IdentityOwner : mints incentives to >
TokenRewards "1" --> "1" PurposeRegistry : enforces purpose catalog >
TokenRewards "1" ..> "1" ConsentManager : triggered on consent creation >
ConsentManager "1" --> "1" PurposeRegistry : validates purpose >
Requester "1" --> "1" PurposeRegistry : selects from catalog >

' Financial Data Service calculates the final score
FinancialDataService "1" --> "1" IdentityRegistry : submits summaries >
FinancialDataService "1" --> "1" DataSharing : requests raw data via

note "Per-purpose consent key = owner + requester + dataType + purpose.\nRewards mint exactly once on SetConsent; no token transfers during data access; tokens only signal access eligibility, data stays off-chain." as N1
N1 .. TokenRewards

note right of IdentityOwner
  Minimal on-chain identity: DID + summary scores + off-chain hash (dataPointer).
  Email/national ID stay off-chain; dedup/verification handled off-chain.
  Assets/Liabilities stored locally as encrypted JSON; hash stored in dataPointer.
end note

@enduml
